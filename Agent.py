from PIL import Image
import math
from Transform import Transform
from ImageUtils import ImageUtils

# Some constant definitions for verbally accessing arrays.
FIRST = 0
SECOND = 1


class Agent:
    """AI agent driver for solving Raven's Progressive Matrices."""

    SKIP = -1
    PROBLEM_FIGURE_NAMES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
    SOLUTION_FIGURE_NAMES = ['1', '2', '3', '4', '5', '6', '7', '8']

    def __init__(self):
        self.problem = None
        self.solution_map = {}

    @staticmethod
    def generate_problem_images(problem):
        """Generate images for each solution and problem figure.

        Args:
            problem (RavensProblem): A object containing all information about
                the RPM problem being solved.

            Returns:
                (dict): Dictionary of problem figures.
                (dict): Dictionary of solution figures.
                    Both dictionary returns respond with a dictionary object
                    in the form of:
                        {
                            'image':  # The figure image as a PIL image.
                            'pixels':  # A list of pixels in the image.
                        }
        """

        problem_figures = {}
        solution_figures = {}
        for figure in problem.figures.itervalues():
            figure_image = Image.open(figure.visualFilename)
            image_pixels = list(figure_image.getdata())
            image_details = dict(image=figure_image, pixels=image_pixels)
            if figure.name in Agent.PROBLEM_FIGURE_NAMES:
                problem_figures[figure.name] = image_details
            elif figure.name in Agent.SOLUTION_FIGURE_NAMES:
                solution_figures[figure.name] = image_details
        return problem_figures, solution_figures

    def Solve(self, problem):
        """The main agent method called for each problem.

        Args:
            problem (RavensProblem): A object containing all information about
                the RPM problem being solved.

        Return:
            (int): The solution generated by the agent.
        """

        self.problem = problem

        if self.problem.problemType == '2x2':
            return self.transformation_match_percentage_strategy()
        else:
            return self.pixel_change_strategy()

    def transformation_match_percentage_strategy(self):
        if self.problem.problemType == '2x2':
            solution_map = {'AB': 'C', 'AC': 'B'}  # , 'BC': 'A'}
        else:
            solution_map = {'AC': 'G', 'DF': 'G', 'AG': 'C', 'BH': 'C'}

        problem_figures, solution_figures = \
            Agent.generate_problem_images(self.problem)

        closest_match = {'name': '-1', 'difference': 2.00}

        # See solution map.
        # Example: 2x2 matrix
        # from_pair: 'AB'
        # apply_to: 'C'
        for from_pair, apply_to in solution_map.iteritems():
            # Find the match between all transformations between the two images.
            image1_data = problem_figures[from_pair[FIRST]]
            image2_data = problem_figures[from_pair[SECOND]]
            images_transformations = \
                Transform.generate_transforms_data(image1_data, image2_data)
            apply_to_image_data = problem_figures[apply_to]
            # Loop over each solution image.
            for solution_name, solution_image_data in \
                    solution_figures.iteritems():
                # Loop over each transformation and see if the transformations
                # match up.
                for transformation in images_transformations.itervalues():
                    apply_to_image_match = transformation.apply_and_compare(
                        apply_to_image_data, solution_image_data)
                    match_difference = \
                        math.fabs(apply_to_image_match - transformation.match)
                    if match_difference < closest_match['difference']:
                        closest_match['name'] = solution_name
                        closest_match['difference'] = match_difference

        return int(closest_match['name'])

    def pixel_change_strategy(self):
        if self.problem.problemType == '2x2':
            solution_map = {'AB': 'C', 'AC': 'B'}  # , 'BC': 'A'}
        else:
            solution_map = {
                'GH': 'H', 'CF': 'F', 'AE': 'E'
            }

        problem_figures, solution_figures = \
            Agent.generate_problem_images(self.problem)

        closest_match = {'name': '-1', 'difference': 100000}

        for from_pair, apply_to in solution_map.iteritems():
            image1_pixels = problem_figures[from_pair[FIRST]]['pixels']
            image2_pixels = problem_figures[from_pair[SECOND]]['pixels']
            image1_black_count = ImageUtils.black_pixel_count(image1_pixels)
            image2_black_count = ImageUtils.black_pixel_count(image2_pixels)
            black_pixel_change = image1_black_count - image2_black_count
            apply_to_image_pixels = problem_figures[apply_to]['pixels']
            apply_to_image_black_count = \
                ImageUtils.black_pixel_count(apply_to_image_pixels)
            for solution_name, solution_image_data in \
                    solution_figures.iteritems():
                solution_image_black_count = \
                    ImageUtils.black_pixel_count(solution_image_data['pixels'])
                apply_to_solution_black_pixel_change = \
                    apply_to_image_black_count - solution_image_black_count
                match_difference = math.fabs(
                    black_pixel_change - apply_to_solution_black_pixel_change)
                if match_difference < closest_match['difference']:
                    closest_match['name'] = solution_name
                    closest_match['difference'] = match_difference

        return int(closest_match['name'])

